import numpy as np
from sklearn.feature_extraction.text import CountVectorizer
from sklearn import svm
from sklearn import preprocessing
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn import utils
import pickle, math

def sigmoid(x):
    ret = []
    for i in x:
        ret.append(1.0 / (1 + math.exp(-i * 1.0)))
    return np.array(ret, dtype=np.float64)

def single_score(Y, Weight1, X1, Weight2, X2):
    lable = sigmoid(Y - np.dot(Weight1, X1)[0])
    pre = sigmoid(np.dot(Weight2, X2)[0])
    lable = np.asarray([round(i) for i in lable], dtype=np.int)
    pre = np.asarray([round(i) for i in pre], dtype=np.int)
    num = 0
    for i in range(0, len(lable)):
        if lable[i] == pre[i]:
            num += 1
    print(num / len(lable))

def both_sorce(Y, Weight1, X1, Weight2, X2):
    pre_Y = sigmoid(np.dot(Weight1, X1)[0]) + sigmoid(np.dot(Weight2, X2)[0])
    # pre_Y = np.asarray([round(i) for i in pre_Y], dtype=np.int)
    num = 0
    for i in range(0, len(Y)):
        if ((pre_Y[i] - Y[i]) > 0.6224593312018546) & (Y[i] == 1):
            num += 1
        if ((pre_Y[i] - Y[i]) <= 0.6224593312018546) & (Y[i] == 0):
            num += 1
    print(num / len(Y))

Bengin_train_sentences = pickle.load(open("BMsave/Bengin_Train_OPCodeList", "r+b"))
Malware_train_sentences = pickle.load(open("BMsave/Malware_Train_OPCodeList", "r+b"))
PC_vocabulary = pickle.load(open("BMsave/Android_vocabulary", "r+b"))
Android_vocabulary = pickle.load(open("BMsave/Android_vocabulary", "r+b"))

Y_train = np.array(([0] * len(Bengin_train_sentences) + [1] * len(Malware_train_sentences)), dtype=np.float64)

PC_vectorizer = CountVectorizer(min_df=0, lowercase=False, vocabulary=PC_vocabulary)

X_train = np.array(PC_vectorizer.transform(Bengin_train_sentences + Malware_train_sentences).toarray(), dtype=np.float64)

public_X_weight = []
min_max_scaler = MinMaxScaler()
X_train = min_max_scaler.fit_transform(X_train)

clf = svm.LinearSVC()
clf.fit(X_train, Y_train)
w = clf.coef_[0]

for index, val in enumerate(w):
    if index in range(0, 36):
        public_X_weight.append(val)
    else:
        break;

print(public_X_weight)

Bengin_test_sentences = pickle.load(open("BMsave/Bengin_Test_OPCodeList", "r+b"))
Malware_test_sentences = pickle.load(open("BMsave/Malware_Test_OPCodeList", "r+b"))
Android_Bengin_train_sentences = Bengin_test_sentences[:200]
Android_Malware_train_sentences = Bengin_test_sentences[:200]
Android_Bengin_test_sentences = Bengin_test_sentences[200:]
Android_Malware_test_sentences = Bengin_test_sentences[200:]

Android_train_Y = np.array(([0] * len(Android_Bengin_train_sentences) + [1] * len(Android_Malware_train_sentences)), dtype=np.float64)
Android_test_Y = np.array(([0] * len(Android_Bengin_test_sentences) + [1] * len(Android_Malware_test_sentences)), dtype=np.float64)
# print(len(Android_train_Y))

Android_vectorizer = CountVectorizer(min_df=0, lowercase=False, vocabulary=Android_vocabulary)

Android_train_X = np.array(Android_vectorizer.transform(Android_Bengin_train_sentences + Android_Malware_train_sentences).toarray(), dtype=np.float64)
Android_test_X = np.array(Android_vectorizer.transform(Android_Bengin_test_sentences + Android_Malware_test_sentences).toarray(), dtype=np.float64)

public_train_X_Smali = []
unique_train_X_Smali = []
for OPCodeList in Android_train_X:
    temp1 = []
    temp2 = []
    for index, data in enumerate(OPCodeList):
        if index in range(0, 36):
            temp1.append(data)
        else:
            temp2.append(data)
    public_train_X_Smali.append(temp1)
    unique_train_X_Smali.append(temp2)

public_test_X_Smali = []
unique_test_X_Smali = []
for OPCodeList in Android_test_X:
    temp1 = []
    temp2 = []
    for index, data in enumerate(OPCodeList):
        if index in range(0, 36):
            temp1.append(data)
        else:
            temp2.append(data)
    public_test_X_Smali.append(temp1)
    unique_test_X_Smali.append(temp2)

public_train_X_Smali = np.array(public_train_X_Smali, dtype=np.float64)
unique_train_X_Smali = np.array(unique_train_X_Smali, dtype=np.float64)
public_train_X_Smali = min_max_scaler.fit_transform(public_train_X_Smali)
unique_train_X_Smali = min_max_scaler.fit_transform(unique_train_X_Smali)
public_test_X_Smali = np.array(public_test_X_Smali, dtype=np.float64)
unique_test_X_Smali = np.array(unique_test_X_Smali, dtype=np.float64)
public_test_X_Smali = min_max_scaler.fit_transform(public_test_X_Smali)
unique_test_X_Smali = min_max_scaler.fit_transform(unique_test_X_Smali)

public_X_weight = [public_X_weight]
# print(len(public_train_X_Smali[0]))
# print(len(public_X_weight))
public_train_X_Smali = np.transpose(public_train_X_Smali)
# public_train_X_Smali = np.array(public_train_X_Smali, dtype=np.float64)
public_X_weight = np.array(public_X_weight, dtype=np.float64)
clf_ = svm.LinearSVC()
# print(np.dot(public_train_X_Smali, public_X_weight)[0])
wv = np.dot(public_X_weight, public_train_X_Smali)[0]
# print(wv)
Y_ = sigmoid(Android_train_Y - wv)
# Y_ = np.asarray([round(i) for i in Y_], dtype=np.int)
# print(Y_)
lab_enc = preprocessing.LabelEncoder()
encoded = lab_enc.fit_transform(Y_)
# print(encoded)
clf_.fit(unique_train_X_Smali, encoded)
unique_X_weight = clf_.coef_[0]
print(unique_X_weight)
unique_X_weight = [unique_X_weight]
unique_X_weight = np.array(unique_X_weight, dtype=np.float64)

public_test_X_Smali = np.transpose(public_test_X_Smali)
unique_test_X_Smali = np.transpose(unique_test_X_Smali)

single_score(Android_test_Y, unique_X_weight, unique_test_X_Smali, public_X_weight, public_test_X_Smali)
single_score(Android_test_Y, public_X_weight, public_test_X_Smali, unique_X_weight, unique_test_X_Smali)
both_sorce(Android_test_Y, public_X_weight, public_test_X_Smali, unique_X_weight, unique_test_X_Smali)
